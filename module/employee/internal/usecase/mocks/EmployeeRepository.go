// Code generated by mockery v2.51.1. DO NOT EDIT.

package mocks

import (
	entity "github.com/eafajri/hr-service.git/module/employee/internal/entity"
	mock "github.com/stretchr/testify/mock"

	time "time"
)

// EmployeeRepository is an autogenerated mock type for the EmployeeRepository type
type EmployeeRepository struct {
	mock.Mock
}

// GetAllAttendanceByTimeRange provides a mock function with given fields: startTime, endTime, userID
func (_m *EmployeeRepository) GetAllAttendanceByTimeRange(startTime time.Time, endTime time.Time, userID *int64) ([]entity.EmployeeAttendance, error) {
	ret := _m.Called(startTime, endTime, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetAllAttendanceByTimeRange")
	}

	var r0 []entity.EmployeeAttendance
	var r1 error
	if rf, ok := ret.Get(0).(func(time.Time, time.Time, *int64) ([]entity.EmployeeAttendance, error)); ok {
		return rf(startTime, endTime, userID)
	}
	if rf, ok := ret.Get(0).(func(time.Time, time.Time, *int64) []entity.EmployeeAttendance); ok {
		r0 = rf(startTime, endTime, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entity.EmployeeAttendance)
		}
	}

	if rf, ok := ret.Get(1).(func(time.Time, time.Time, *int64) error); ok {
		r1 = rf(startTime, endTime, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllOvertimeByTimeRange provides a mock function with given fields: startTime, endTime, userID
func (_m *EmployeeRepository) GetAllOvertimeByTimeRange(startTime time.Time, endTime time.Time, userID *int64) ([]entity.EmployeeOvertime, error) {
	ret := _m.Called(startTime, endTime, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetAllOvertimeByTimeRange")
	}

	var r0 []entity.EmployeeOvertime
	var r1 error
	if rf, ok := ret.Get(0).(func(time.Time, time.Time, *int64) ([]entity.EmployeeOvertime, error)); ok {
		return rf(startTime, endTime, userID)
	}
	if rf, ok := ret.Get(0).(func(time.Time, time.Time, *int64) []entity.EmployeeOvertime); ok {
		r0 = rf(startTime, endTime, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entity.EmployeeOvertime)
		}
	}

	if rf, ok := ret.Get(1).(func(time.Time, time.Time, *int64) error); ok {
		r1 = rf(startTime, endTime, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllReimbursementByTimeRange provides a mock function with given fields: startTime, endTime, userID
func (_m *EmployeeRepository) GetAllReimbursementByTimeRange(startTime time.Time, endTime time.Time, userID *int64) ([]entity.EmployeeReimbursement, error) {
	ret := _m.Called(startTime, endTime, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetAllReimbursementByTimeRange")
	}

	var r0 []entity.EmployeeReimbursement
	var r1 error
	if rf, ok := ret.Get(0).(func(time.Time, time.Time, *int64) ([]entity.EmployeeReimbursement, error)); ok {
		return rf(startTime, endTime, userID)
	}
	if rf, ok := ret.Get(0).(func(time.Time, time.Time, *int64) []entity.EmployeeReimbursement); ok {
		r0 = rf(startTime, endTime, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entity.EmployeeReimbursement)
		}
	}

	if rf, ok := ret.Get(1).(func(time.Time, time.Time, *int64) error); ok {
		r1 = rf(startTime, endTime, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAttendanceByUserAndDate provides a mock function with given fields: userID, date
func (_m *EmployeeRepository) GetAttendanceByUserAndDate(userID int64, date time.Time) (entity.EmployeeAttendance, error) {
	ret := _m.Called(userID, date)

	if len(ret) == 0 {
		panic("no return value specified for GetAttendanceByUserAndDate")
	}

	var r0 entity.EmployeeAttendance
	var r1 error
	if rf, ok := ret.Get(0).(func(int64, time.Time) (entity.EmployeeAttendance, error)); ok {
		return rf(userID, date)
	}
	if rf, ok := ret.Get(0).(func(int64, time.Time) entity.EmployeeAttendance); ok {
		r0 = rf(userID, date)
	} else {
		r0 = ret.Get(0).(entity.EmployeeAttendance)
	}

	if rf, ok := ret.Get(1).(func(int64, time.Time) error); ok {
		r1 = rf(userID, date)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEmployeeBaseSalaryByPeriodStart provides a mock function with given fields: periodStartTime, userID
func (_m *EmployeeRepository) GetEmployeeBaseSalaryByPeriodStart(periodStartTime time.Time, userID *int64) ([]entity.EmployeeBaseSalary, error) {
	ret := _m.Called(periodStartTime, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetEmployeeBaseSalaryByPeriodStart")
	}

	var r0 []entity.EmployeeBaseSalary
	var r1 error
	if rf, ok := ret.Get(0).(func(time.Time, *int64) ([]entity.EmployeeBaseSalary, error)); ok {
		return rf(periodStartTime, userID)
	}
	if rf, ok := ret.Get(0).(func(time.Time, *int64) []entity.EmployeeBaseSalary); ok {
		r0 = rf(periodStartTime, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entity.EmployeeBaseSalary)
		}
	}

	if rf, ok := ret.Get(1).(func(time.Time, *int64) error); ok {
		r1 = rf(periodStartTime, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertAttendance provides a mock function with given fields: record
func (_m *EmployeeRepository) UpsertAttendance(record entity.EmployeeAttendance) error {
	ret := _m.Called(record)

	if len(ret) == 0 {
		panic("no return value specified for UpsertAttendance")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(entity.EmployeeAttendance) error); ok {
		r0 = rf(record)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertOvertime provides a mock function with given fields: record
func (_m *EmployeeRepository) UpsertOvertime(record entity.EmployeeOvertime) error {
	ret := _m.Called(record)

	if len(ret) == 0 {
		panic("no return value specified for UpsertOvertime")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(entity.EmployeeOvertime) error); ok {
		r0 = rf(record)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertReimbursement provides a mock function with given fields: record
func (_m *EmployeeRepository) UpsertReimbursement(record entity.EmployeeReimbursement) error {
	ret := _m.Called(record)

	if len(ret) == 0 {
		panic("no return value specified for UpsertReimbursement")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(entity.EmployeeReimbursement) error); ok {
		r0 = rf(record)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewEmployeeRepository creates a new instance of EmployeeRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEmployeeRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *EmployeeRepository {
	mock := &EmployeeRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
